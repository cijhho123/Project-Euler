/*	Problem 29 - Distinct powers:
	Consider all integer combinations of ab for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:

	2^2=4, 2^3=8, 2^4=16, 2^5=32
	3^2=9, 3^3=27, 3^4=81, 3^5=243
	4^2=16, 4^3=64, 4^4=256, 4^5=1024
	5^2=25, 5^3=125, 5^4=625, 5^5=3125
	If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:

	4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

	How many distinct terms are in the sequence generated by ab for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100? 

*/
package euler;

import java.math.BigDecimal;
import java.util.HashMap;

public class projectEuler {
	
	public static void main (String [] args){
		//method 1 - pen and paper
		long time = System.nanoTime();
		//initialize the values per power
		//	the calculations have been done with pen and paper, for extended explanation visit:
		//	https://www.mathblog.dk/project-euler-29-distinct-terms-sequence-ab/
		int[] distinct = new int [7];	//2^6 is the highest power less than 100
		distinct[1] = 99;	//if n is in the form a^1 there are 99 distinct numbers
		distinct[2] = 50;	//if n is in the form a^2 there are 50 distinct numbers
		distinct[3] = 50;	//if n is in the form a^3 there are 50 distinct numbers
		distinct[4] = 41;	//if n is in the form a^4 there are 41 distinct numbers
		distinct[5] = 51;	//if n is in the form a^5 there are 51 distinct numbers
		distinct[6] = 37;	//if n is in the form a^6 there are 37 distinct numbers
		
		int distinctNumbers = 0;
		
		for(int i = 2; i <= 100; i++) {
			distinctNumbers += distinct[maxPower(i)];	
		}
		time =  System.nanoTime() - time;
		System.out.println("there are "+distinctNumbers+" distinct numbers\nIt took "+(time/1000000)+"ms to execute\n\n\n");
		
		//----------------------------------------------------------------------------------------------
		//method #2 - hashmap with BigDecimal as keys
		time =  System.nanoTime();
		
		HashMap <BigDecimal, Boolean> distinctNumber  = new HashMap<BigDecimal, Boolean>();
		//note: because a normal Double can handle enough digits for it to be one-to-one mapping i had to use BigDecimal
		for(int base = 2; base <= 100; base++)
			for(int exp = 2; exp <= 100; exp++) {
				BigDecimal big = new BigDecimal(base).pow(exp);
				if(!distinctNumber.containsKey(big))
					distinctNumber.put(big, true);
				
			}
		
		time =  System.nanoTime() - time;
		System.out.println("there are "+distinctNumber.size()+" distinct numbers\nIt took "+(time/1000000)+"ms to execute");
	}

	public static int maxPower(int n) {
		//calculate the maximun power b, such that n = a^b
		//note: the highest power possible is 6 because 2^7 > 100
		for(int base = 2; base <= Math.sqrt(n); base++)
			for(int exp = 2; exp < 7; exp++)
				if(Math.pow(base, exp) == n)
					return exp;
		return 1; 
	}
}
